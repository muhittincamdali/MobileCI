# Fastfile - iOS CI/CD Automation
# Comprehensive lanes for building, testing, and deploying iOS apps
# Version: 2.0.0

default_platform(:ios)

# ============================================================================
# CONSTANTS AND CONFIGURATION
# ============================================================================

WORKSPACE = ENV['WORKSPACE_NAME'] || 'App.xcworkspace'
PROJECT = ENV['PROJECT_NAME'] || 'App.xcodeproj'
SCHEME = ENV['SCHEME_NAME'] || 'App'
BUNDLE_ID = ENV['BUNDLE_IDENTIFIER'] || 'com.company.app'
TEAM_ID = ENV['TEAM_ID']
APP_STORE_CONNECT_API_KEY_ID = ENV['APP_STORE_CONNECT_API_KEY_ID']
APP_STORE_CONNECT_ISSUER_ID = ENV['APP_STORE_CONNECT_ISSUER_ID']
SLACK_WEBHOOK_URL = ENV['SLACK_WEBHOOK_URL']
FIREBASE_APP_ID = ENV['FIREBASE_APP_ID']

# Build configurations
CONFIGURATIONS = {
  debug: 'Debug',
  release: 'Release',
  staging: 'Staging',
  production: 'Production'
}.freeze

# Destinations
DESTINATIONS = {
  testflight: 'testflight',
  app_store: 'app_store',
  firebase: 'firebase',
  adhoc: 'adhoc'
}.freeze

# ============================================================================
# BEFORE ALL - Setup and Validation
# ============================================================================

before_all do |lane, options|
  # Ensure clean git status for release lanes
  if [:release, :beta, :app_store].include?(lane)
    ensure_git_status_clean unless options[:skip_git_check]
  end
  
  # Setup CI environment
  setup_ci if is_ci
  
  # Check for required environment variables
  validate_environment(lane)
  
  # Clear derived data for clean builds
  clear_derived_data if options[:clean]
  
  UI.message("Starting lane: #{lane}")
  UI.message("Options: #{options}")
end

# ============================================================================
# AFTER ALL - Cleanup and Notifications
# ============================================================================

after_all do |lane, options|
  # Clean up temporary files
  clean_build_artifacts unless options[:keep_artifacts]
  
  # Send success notification
  notify_slack(
    message: "Lane '#{lane}' completed successfully! ðŸŽ‰",
    success: true
  ) if SLACK_WEBHOOK_URL && options[:notify]
  
  UI.success("Lane '#{lane}' completed successfully!")
end

# ============================================================================
# ERROR HANDLING
# ============================================================================

error do |lane, exception, options|
  # Send failure notification
  notify_slack(
    message: "Lane '#{lane}' failed: #{exception.message}",
    success: false
  ) if SLACK_WEBHOOK_URL
  
  # Upload crash logs if available
  upload_crash_logs if File.exist?('../crash_logs')
  
  UI.error("Lane '#{lane}' failed: #{exception.message}")
end

# ============================================================================
# PLATFORM: iOS
# ============================================================================

platform :ios do
  
  # ==========================================================================
  # SETUP LANES
  # ==========================================================================
  
  desc "Setup development environment"
  lane :setup do |options|
    # Install CocoaPods dependencies
    cocoapods(
      clean_install: options[:clean] || false,
      use_bundle_exec: true,
      try_repo_update_on_error: true
    )
    
    # Setup code signing with match
    setup_signing(type: 'development')
    
    # Generate project if using XcodeGen
    if File.exist?('../project.yml')
      sh('cd .. && xcodegen generate')
    end
    
    # Install git hooks
    sh('cd .. && cp -r .githooks/* .git/hooks/ 2>/dev/null || true')
    
    UI.success("Development environment setup complete!")
  end
  
  desc "Setup CI environment"
  lane :setup_ci_env do
    setup_ci(
      provider: 'github_actions',
      force: true
    )
    
    # Create keychain for CI
    create_keychain(
      name: 'ci_keychain',
      password: ENV['KEYCHAIN_PASSWORD'] || 'temp_password',
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
  end
  
  # ==========================================================================
  # CODE SIGNING LANES
  # ==========================================================================
  
  desc "Setup code signing with match"
  lane :setup_signing do |options|
    type = options[:type] || 'appstore'
    readonly = options[:readonly] != false
    
    # Sync certificates and profiles
    match(
      type: type,
      app_identifier: BUNDLE_ID,
      team_id: TEAM_ID,
      readonly: readonly,
      keychain_name: is_ci ? 'ci_keychain' : nil,
      keychain_password: is_ci ? ENV['KEYCHAIN_PASSWORD'] : nil,
      verbose: options[:verbose] || false
    )
    
    # Handle app extensions if present
    app_extensions = options[:extensions] || []
    app_extensions.each do |ext_bundle_id|
      match(
        type: type,
        app_identifier: ext_bundle_id,
        team_id: TEAM_ID,
        readonly: readonly
      )
    end
  end
  
  desc "Renew push notification certificates"
  lane :renew_push_certificate do |options|
    get_push_certificate(
      app_identifier: BUNDLE_ID,
      team_id: TEAM_ID,
      generate_p12: true,
      active_days_limit: 30,
      new_profile: options[:force] || false,
      save_private_key: true,
      output_path: './certificates'
    )
  end
  
  desc "Register new devices"
  lane :register_devices do |options|
    device_file = options[:file] || './devices.txt'
    
    register_devices(
      devices_file: device_file,
      team_id: TEAM_ID
    )
    
    # Refresh development profiles
    match(
      type: 'development',
      force_for_new_devices: true
    )
    
    match(
      type: 'adhoc',
      force_for_new_devices: true
    )
  end
  
  # ==========================================================================
  # BUILD LANES
  # ==========================================================================
  
  desc "Build for development"
  lane :build_dev do |options|
    setup_signing(type: 'development')
    
    build_ios_app(
      workspace: WORKSPACE,
      scheme: SCHEME,
      configuration: CONFIGURATIONS[:debug],
      export_method: 'development',
      output_directory: './build',
      output_name: 'App-Dev.ipa',
      clean: options[:clean] || false,
      include_bitcode: false,
      include_symbols: true,
      xcargs: build_xcargs(options)
    )
  end
  
  desc "Build for staging/QA"
  lane :build_staging do |options|
    setup_signing(type: 'adhoc')
    
    # Increment build number
    increment_build_number_if_needed
    
    build_ios_app(
      workspace: WORKSPACE,
      scheme: SCHEME,
      configuration: CONFIGURATIONS[:staging],
      export_method: 'ad-hoc',
      output_directory: './build',
      output_name: 'App-Staging.ipa',
      clean: true,
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        compileBitcode: false,
        uploadSymbols: true,
        thinning: '<none>'
      }
    )
  end
  
  desc "Build for production/release"
  lane :build_release do |options|
    setup_signing(type: 'appstore')
    
    # Increment build number
    increment_build_number_if_needed
    
    build_ios_app(
      workspace: WORKSPACE,
      scheme: SCHEME,
      configuration: CONFIGURATIONS[:production],
      export_method: 'app-store',
      output_directory: './build',
      output_name: 'App-Release.ipa',
      clean: true,
      include_bitcode: true,
      include_symbols: true,
      export_options: {
        uploadSymbols: true,
        compileBitcode: true
      }
    )
  end
  
  desc "Build xcframework for distribution"
  lane :build_xcframework do |options|
    schemes = options[:schemes] || [SCHEME]
    output_path = options[:output] || './build/XCFrameworks'
    
    schemes.each do |scheme_name|
      # Build for iOS device
      xcodebuild(
        workspace: WORKSPACE,
        scheme: scheme_name,
        configuration: 'Release',
        destination: 'generic/platform=iOS',
        archive: true,
        archive_path: "./build/#{scheme_name}-iOS.xcarchive",
        xcargs: 'SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES'
      )
      
      # Build for iOS Simulator
      xcodebuild(
        workspace: WORKSPACE,
        scheme: scheme_name,
        configuration: 'Release',
        destination: 'generic/platform=iOS Simulator',
        archive: true,
        archive_path: "./build/#{scheme_name}-Simulator.xcarchive",
        xcargs: 'SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES'
      )
      
      # Create XCFramework
      sh("xcodebuild -create-xcframework \
          -framework ./build/#{scheme_name}-iOS.xcarchive/Products/Library/Frameworks/#{scheme_name}.framework \
          -framework ./build/#{scheme_name}-Simulator.xcarchive/Products/Library/Frameworks/#{scheme_name}.framework \
          -output #{output_path}/#{scheme_name}.xcframework")
    end
  end
  
  # ==========================================================================
  # TEST LANES
  # ==========================================================================
  
  desc "Run all tests"
  lane :test do |options|
    # Run unit tests
    test_unit(options)
    
    # Run UI tests if not skipped
    test_ui(options) unless options[:skip_ui_tests]
    
    # Run snapshot tests if available
    test_snapshots(options) if options[:snapshots]
    
    # Generate coverage report
    generate_coverage_report if options[:coverage]
  end
  
  desc "Run unit tests"
  lane :test_unit do |options|
    run_tests(
      workspace: WORKSPACE,
      scheme: options[:scheme] || SCHEME,
      device: options[:device] || 'iPhone 15 Pro',
      code_coverage: true,
      output_directory: './test_results',
      output_types: 'junit,html',
      result_bundle: true,
      parallel_testing: options[:parallel] != false,
      concurrent_workers: options[:workers] || 4,
      max_concurrent_simulators: options[:simulators] || 2,
      testplan: options[:testplan],
      only_testing: options[:only_testing],
      skip_testing: options[:skip_testing],
      fail_build: options[:fail_build] != false,
      xcargs: '-enableCodeCoverage YES'
    )
  end
  
  desc "Run UI tests"
  lane :test_ui do |options|
    run_tests(
      workspace: WORKSPACE,
      scheme: options[:ui_scheme] || "#{SCHEME}UITests",
      device: options[:device] || 'iPhone 15 Pro',
      code_coverage: false,
      output_directory: './test_results/ui',
      output_types: 'junit,html',
      result_bundle: true,
      prelaunch_simulator: true,
      reinstall_app: true,
      testplan: options[:ui_testplan],
      fail_build: options[:fail_build] != false
    )
  end
  
  desc "Run snapshot tests"
  lane :test_snapshots do |options|
    run_tests(
      workspace: WORKSPACE,
      scheme: options[:snapshot_scheme] || "#{SCHEME}SnapshotTests",
      device: options[:device] || 'iPhone 15 Pro',
      output_directory: './test_results/snapshots',
      output_types: 'junit,html',
      result_bundle: true,
      clean: true
    )
    
    # Archive snapshot differences if any
    if File.exist?('../SnapshotDiffs')
      zip(
        path: '../SnapshotDiffs',
        output_path: './test_results/snapshot_diffs.zip'
      )
    end
  end
  
  desc "Generate coverage report"
  private_lane :generate_coverage_report do
    xcov(
      workspace: WORKSPACE,
      scheme: SCHEME,
      output_directory: './coverage',
      html_report: true,
      json_report: true,
      minimum_coverage_percentage: 70.0,
      ignore_file_path: '.xcovignore'
    )
    
    # Upload to Codecov if token available
    if ENV['CODECOV_TOKEN']
      sh('bash <(curl -s https://codecov.io/bash) -f ./coverage/coverage.json')
    end
  end
  
  # ==========================================================================
  # DEPLOYMENT LANES
  # ==========================================================================
  
  desc "Deploy to TestFlight"
  lane :beta do |options|
    # Build release version
    build_release(options)
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: options[:skip_waiting] || false,
      distribute_external: options[:external] || false,
      groups: options[:groups] || ['Internal Testers'],
      changelog: options[:changelog] || generate_changelog,
      notify_external_testers: options[:notify] != false,
      expire_previous_builds: true,
      reject_build_waiting_for_review: true
    )
    
    # Upload dSYMs to Crashlytics
    upload_symbols_to_crashlytics if should_upload_dsyms?
    
    # Tag the release
    add_git_tag(
      tag: "beta/#{get_version_number}/#{get_build_number}"
    ) unless options[:skip_tag]
    
    UI.success("Successfully deployed to TestFlight! ðŸš€")
  end
  
  desc "Deploy to App Store"
  lane :release do |options|
    # Ensure we're on main branch
    ensure_git_branch(branch: 'main') unless options[:skip_branch_check]
    
    # Version bump
    version = options[:version] || prompt_for_version
    increment_version_number(version_number: version)
    increment_build_number_if_needed
    
    # Build release version
    build_release(options)
    
    # Upload to App Store Connect
    upload_to_app_store(
      skip_metadata: options[:skip_metadata] || false,
      skip_screenshots: options[:skip_screenshots] || true,
      force: options[:force] || false,
      submit_for_review: options[:submit] || false,
      automatic_release: options[:automatic_release] || false,
      phased_release: options[:phased_release] || true,
      submission_information: {
        add_id_info_uses_idfa: false,
        export_compliance_uses_encryption: false
      },
      precheck_include_in_app_purchases: false
    )
    
    # Upload dSYMs
    upload_symbols_to_crashlytics if should_upload_dsyms?
    
    # Commit version bump
    commit_version_bump(
      message: "chore(release): bump version to #{version}",
      xcodeproj: PROJECT
    )
    
    # Tag the release
    add_git_tag(
      tag: "v#{version}"
    )
    
    # Push changes
    push_to_git_remote unless options[:skip_push]
    
    # Create GitHub release
    create_github_release(version: version) if options[:github_release]
    
    UI.success("Successfully released v#{version} to App Store! ðŸŽ‰")
  end
  
  desc "Deploy to Firebase App Distribution"
  lane :firebase do |options|
    # Build adhoc version
    build_staging(options)
    
    # Upload to Firebase
    firebase_app_distribution(
      app: FIREBASE_APP_ID,
      ipa_path: './build/App-Staging.ipa',
      groups: options[:groups] || 'qa-team',
      release_notes: options[:notes] || generate_changelog,
      firebase_cli_token: ENV['FIREBASE_CLI_TOKEN']
    )
    
    UI.success("Successfully deployed to Firebase App Distribution! ðŸ”¥")
  end
  
  # ==========================================================================
  # VERSION MANAGEMENT LANES
  # ==========================================================================
  
  desc "Bump version number"
  lane :bump_version do |options|
    bump_type = options[:type] || 'patch'
    
    case bump_type
    when 'major'
      increment_version_number(bump_type: 'major')
    when 'minor'
      increment_version_number(bump_type: 'minor')
    when 'patch'
      increment_version_number(bump_type: 'patch')
    else
      increment_version_number(version_number: bump_type)
    end
    
    commit_version_bump(
      message: "chore(version): bump to #{get_version_number}",
      xcodeproj: PROJECT
    )
  end
  
  desc "Sync version from marketing version"
  lane :sync_version do |options|
    version = get_version_number(xcodeproj: PROJECT)
    
    # Update all targets
    increment_version_number(
      version_number: version,
      xcodeproj: PROJECT
    )
    
    # Update podspec if exists
    update_podspec_version(version) if File.exist?('../*.podspec')
    
    # Update package.json if hybrid app
    update_package_json_version(version) if File.exist?('../package.json')
  end
  
  # ==========================================================================
  # UTILITY LANES
  # ==========================================================================
  
  desc "Clean build artifacts"
  lane :clean do
    clear_derived_data
    clean_build_artifacts
    sh('rm -rf ../build')
    sh('rm -rf ../test_results')
    sh('rm -rf ../coverage')
    UI.success("Build artifacts cleaned!")
  end
  
  desc "Update dependencies"
  lane :update_deps do |options|
    # Update CocoaPods
    cocoapods(
      repo_update: true,
      use_bundle_exec: true
    )
    
    # Update Swift packages
    sh('cd .. && swift package update') if File.exist?('../Package.swift')
    
    # Commit changes
    if options[:commit]
      git_commit(
        path: ['Podfile.lock', 'Package.resolved'],
        message: 'chore(deps): update dependencies'
      )
    end
  end
  
  desc "Generate app icons"
  lane :generate_icons do |options|
    appicon(
      appicon_image_file: options[:source] || 'Resources/AppIcon.png',
      appicon_devices: [:iphone, :ipad, :watch, :mac],
      appicon_path: options[:path] || 'App/Assets.xcassets'
    )
  end
  
  desc "Take screenshots"
  lane :screenshots do |options|
    capture_screenshots(
      workspace: WORKSPACE,
      scheme: "#{SCHEME}UITests",
      devices: options[:devices] || [
        'iPhone 15 Pro Max',
        'iPhone 15 Pro',
        'iPhone SE (3rd generation)',
        'iPad Pro (12.9-inch) (6th generation)'
      ],
      languages: options[:languages] || ['en-US', 'de-DE', 'ja'],
      output_directory: './screenshots',
      clear_previous_screenshots: true,
      concurrent_simulators: true
    )
    
    frame_screenshots(
      path: './screenshots'
    ) if options[:frame]
  end
  
  desc "Refresh dSYMs from App Store Connect"
  lane :refresh_dsyms do |options|
    download_dsyms(
      version: options[:version] || 'latest',
      build_number: options[:build],
      output_directory: './dsyms'
    )
    
    upload_symbols_to_crashlytics(
      dsym_path: './dsyms'
    )
    
    clean_build_artifacts
  end
  
  # ==========================================================================
  # HELPER METHODS
  # ==========================================================================
  
  private_lane :validate_environment do |lane|
    required_vars = case lane
    when :release, :beta, :app_store
      ['TEAM_ID', 'MATCH_PASSWORD']
    when :firebase
      ['FIREBASE_APP_ID', 'FIREBASE_CLI_TOKEN']
    else
      []
    end
    
    missing = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing.empty?
      UI.user_error!("Missing required environment variables: #{missing.join(', ')}")
    end
  end
  
  private_lane :increment_build_number_if_needed do
    if is_ci
      # Use CI build number
      build_number = ENV['GITHUB_RUN_NUMBER'] || ENV['BUILD_NUMBER'] || latest_testflight_build_number + 1
      increment_build_number(build_number: build_number)
    else
      increment_build_number
    end
  end
  
  private_lane :build_xcargs do |options|
    xcargs = []
    xcargs << "DEVELOPMENT_TEAM=#{TEAM_ID}" if TEAM_ID
    xcargs << "CODE_SIGN_STYLE=Manual" if is_ci
    xcargs << options[:extra_xcargs] if options[:extra_xcargs]
    xcargs.join(' ')
  end
  
  private_lane :generate_changelog do
    changelog = changelog_from_git_commits(
      commits_count: 10,
      pretty: 'â€¢ %s',
      merge_commit_filtering: 'exclude_merges'
    )
    changelog.empty? ? 'Bug fixes and improvements' : changelog
  end
  
  private_lane :should_upload_dsyms? do
    ENV['FIREBASE_APP_ID'] && File.exist?('../build/App-Release.app.dSYM.zip')
  end
  
  private_lane :upload_crash_logs do
    if File.exist?('../crash_logs')
      zip(path: '../crash_logs', output_path: './crash_logs.zip')
    end
  end
  
  private_lane :notify_slack do |options|
    return unless SLACK_WEBHOOK_URL
    
    slack(
      message: options[:message],
      success: options[:success],
      slack_url: SLACK_WEBHOOK_URL,
      default_payloads: [:git_branch, :git_author],
      attachment_properties: {
        fields: [
          {
            title: 'App Version',
            value: get_version_number,
            short: true
          },
          {
            title: 'Build Number',
            value: get_build_number,
            short: true
          }
        ]
      }
    )
  end
  
  private_lane :prompt_for_version do
    current = get_version_number
    UI.input("Enter new version (current: #{current}): ")
  end
  
  private_lane :update_podspec_version do |version|
    version_bump_podspec(
      version_number: version
    )
  end
  
  private_lane :update_package_json_version do |version|
    sh("cd .. && npm version #{version} --no-git-tag-version")
  end
  
  private_lane :create_github_release do |options|
    set_github_release(
      repository_name: ENV['GITHUB_REPOSITORY'],
      tag_name: "v#{options[:version]}",
      name: "Release #{options[:version]}",
      description: generate_changelog,
      commitish: 'main',
      upload_assets: ['./build/App-Release.ipa']
    )
  end

end
